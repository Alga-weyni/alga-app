ðŸ§­ Step 3. Redirect Based on Role After Login

Once the login succeeds, use the role to determine where to go.
Hereâ€™s the client-side redirect logic (React or Next.js):

import { useRouter } from 'next/router';
import { signIn } from 'next-auth/react';

const handleLogin = async (e) => {
  e.preventDefault();
  const result = await signIn('credentials', {
    redirect: false,
    email,
    password,
  });

  if (result.ok) {
    const sessionRes = await fetch('/api/auth/session');
    const session = await sessionRes.json();
    const role = session.user.role;

    switch (role) {
      case 'admin':
        router.push('/admin/dashboard');
        break;
      case 'host':
        router.push('/host/dashboard');
        break;
      case 'operator':
        router.push('/operator/dashboard');
        break;
      case 'tenant':
        router.push('/tenant/home');
        break;
      default:
        router.push('/');
    }
  } else {
    alert('Invalid credentials');
  }
};


âœ… Result:

Admins go to /admin/dashboard

Hosts go to /host/dashboard

Operators go to /operator/dashboard

Tenants go to /tenant/home

ðŸ”’ Step 4. Protect Pages by Role (Access Control)

Now ensure each page checks the userâ€™s role before showing content:

Example: /pages/admin/dashboard.js
import { useSession } from "next-auth/react";
import { useRouter } from "next/router";

export default function AdminDashboard() {
  const { data: session, status } = useSession();
  const router = useRouter();

  if (status === "loading") return <p>Loading...</p>;
  if (!session) {
    router.push("/auth/signin");
    return null;
  }

  if (session.user.role !== "admin") {
    router.push("/unauthorized");
    return null;
  }

  return <h1>Welcome Admin {session.user.email}</h1>;
}


âœ… This ensures:

Non-admins canâ€™t manually access the admin route.

The system redirects unauthorized users to /unauthorized.

ðŸ§± Step 5. (Optional) Add Middleware for Automatic Protection

To make protection global and automatic:
Create a file /middleware.js in your project root:

import { getToken } from "next-auth/jwt";
import { NextResponse } from "next/server";

export async function middleware(req) {
  const token = await getToken({ req });
  const path = req.nextUrl.pathname;

  if (path.startsWith("/admin") && token?.role !== "admin") {
    return NextResponse.redirect(new URL("/unauthorized", req.url));
  }
  if (path.startsWith("/host") && token?.role !== "host") {
    return NextResponse.redirect(new URL("/unauthorized", req.url));
  }
  if (path.startsWith("/operator") && token?.role !== "operator") {
    return NextResponse.redirect(new URL("/unauthorized", req.url));
  }
  if (path.startsWith("/tenant") && token?.role !== "tenant") {
    return NextResponse.redirect(new URL("/unauthorized", req.url));
  }

  return NextResponse.next();
}


âœ… This means you never have to manually protect each page again â€” the middleware handles it automatically.

ðŸŽ¯ Summary: Fix Path
Step	Action	File	Purpose
1	Confirm user role column exists	DB	Ensure distinct roles
2	Return role in auth response	API/Auth	Attach user role to session
3	Add role-based redirect after login	/auth/signin.js	Send users to correct dashboard
4	Protect pages by role	/admin, /host, etc.	Prevent unauthorized access
5	Add middleware (optional but recommended)	/middleware.js	Global route protection